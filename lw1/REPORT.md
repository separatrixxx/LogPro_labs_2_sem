# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Лохматов Н. И.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

В отличие от императивных языков программирования, в прологе не получится использовать массивы с индексацией и доступом к любому элементу, однако все способы реализации данных в прологе можно реализовать и на императивных языках. Однако есть и схожие черты, например, односвязные списки: текущий элемент (голова) + ссылка на следующий (хвост). Также в прологе списки могут содержать элементы, имеющие разные типы. Такие же особенности есть у списков языка Python, а также у кортежей в C++.

## Задание 1.1: Предикат обработки списка

`n_elem(N,L,X) и n_elem_standart` - получают N-ный элемент списка (вариант 9)

Примеры использования:
```prolog
?- n_elem(0, [1,2,3,4,5,6,7], X).
X = 1.

?- n_elem(4, [1,2,3,4,5,6,7], X).  
X = 5.
      
?- n_elem(10, [1,2,3,4,5,6,7], X). 
false.

?- n_elem(4, X, 5).               
X = [_, _, _, _, 5|_].

?- n_elem(4, [1,2,3,4,5,6,7], 5). 
true.

?- n_elem_standart(X, [1,2,3,4,5,6,7], Y).   
X = 0,
Y = 1 ;
X = 1,
Y = 2 ;
X = 2,
Y = 3 ;
X = 3,
Y = 4 ;
X = 4,
Y = 5 ;
X = 5,
Y = 6 ;
X = 6,
Y = 7 ;
false.

?- n_elem_standart(X, [1,2,3,4,5,6,7], 7). 
X = 6

```

Реализация:
```prolog
n_elem(0, [H|_], H):-!.
n_elem(N, [_|L], X):-
    Num is N - 1,
    n_elem(Num, L, X).

%Реализация на основе стандартных предикатов обработки списков
n_elem_standart(N, L, X):-
    append(A, [X|_], L),
    length(A, N).
```

`n_elem` - получает три аргумента: номер элемента списка N, список и этот N-ый элемент.
С каждым шагом мы убираем у списка первый элемент и уменьшаем N на единицу.
Если N окажется равным нулю, то первый элемент полученного списка L - это и есть искомый N-ый элемент. 
Первая строка и находит этот элемент.

`n_elem_standart` - копирует в список A элементы из данного списка до X, находит длину A - это и есть номер элемента X

## Задание 1.2: Предикат обработки числового списка

`check_geom_progress` - проверяет список на геометрическую прогрессию (вариант 14)

Примеры использования:
```prolog
?- check_geom_progress([1,2,4,8,16,32]).
true.

?- check_geom_progress_standart([1,2,4,8,16,3]).  
false.

```

Реализация:
```prolog
check_geom_progress(L):-
    L = [X, Y|_],
    D is Y / X,
    check_geom_progress(L, D).
check_geom_progress([_], _):-!.
check_geom_progress([X, Y|T], D):-
    D is Y / X,
    check_geom_progress([Y|T], D).
    
%Реализация на основе стандартных предикатов обработки списков
del_first(L,R):- 
    append([_],R,L).
check_geom_progress_standart(L):-
    L = [X, Y|_],
    D is Y / X,
    del_first(L,R),
    check_geom_progress_standart(R, D).
check_geom_progress_standart([_], _):-!.
check_geom_progress_standart(R, D):-
    R = [X, Y|_],
    D is Y / X,
    del_first(R,R1),
    check_geom_progress_standart(R1, D).
```

`check_geom_progress` - ищет D - знаменатель прогрессии, делит список на два первых элемента и хвост, проверяет, отличается ли второй элемент от первого в D раз, если да, продолжает делить список, иначе - не геометрическая прогрессия.

`check_geom_progress_standart` - в принципе, делает то же самое, что и `check_geom_progress`, но только ращделение списка на элементы происходит с помощью побочной функции `del_first`, которая удаляет первый элемент у списка.

### Пример совместного использования предикатов, реализованных в пунктах 3 и 4

Реализация метода `pop();` из JS на прологе. Предикат получает на вход список и две переменные. Удаляет последний элемент списка и возвращет его. Также для наглядности выводит получившийся список.

Реализация:
```prolog
my_pop(L, R, Last) :-
    mylength(L, Len),
    LastPos is Len - 1,
    n_elem(LastPos, L, Last),
    append(R, [_], L).
```

Примеры использования:
```prolog
?- my_pop([1,2,3,4,5], L, R).
L = [1, 2, 3, 4],
R = 5
```

## Задание 2: Реляционное представление данных

Модель реляционного представления довольно простая и лёгкая для понимания, что, безусловно, является её плюсом. Из недостатков - могут появится трудности при разработке в достаточно простых местах.

В моём представлении, наверное, очень просто получить всех студентов и их оценки, поэтому найти средний балл или студентов, заваливших сессию, было легко.

### Предикаты первого задания:

Для каждого студента, найти средний балл, и сдал ли он экзамены или нет

`sum(List, S)`, где List - это список, S - сумма элементов. 

Реализация: 

```prolog
sum([], 0).
sum([X|Y], S) :-
    sum(Y, S1),
    S is S1 + X.
```

Пример работы:

```prolog
?- sum([1,2,3,4,5], S).
S = 15.
```

Этот предикат считает сумму элементов списка, нужен был для вычисления среднего арифметического, работает достаточно примитивно.

`sr(L, R)`, где L - это список, R - среднее арифметическое его элементов. 

Реализация: 

```prolog
sr(L, R) :-
    length(L, Len),
    sum(L, Sum),
    R is Sum / Len.
```

Пример работы:

```prolog
?- sr([1,2,3,4,5], S).  
S = 3.
```

Вычисляет среднее арифметическое: считает сумму элементов и длину, потом делит.

`get_student_sr(Name, SrGrades)`, где Name - имя студента, SrGrades - его средний балл.

Реализация: 

```prolog
get_student_sr(Name, SrGrades) :-
    findall(Mark, grade(Name, _, Mark), List),
    sr(List, SrGrades).
```

Пример работы:

```prolog
?- get_student_sr('Иванов', Sr).
Sr = 4.5.
```

Получает средний ббалл студента. Сначала получает все оценки, потом считает среднее с помощью вышеописанного предиката `sr(L, R)`.

`pass_exam(Name)`, где Name - имя студента. 

Реализация: 

```prolog
pass_exam(Name) :-
    findall(Mark, grade(Name, _, Mark), List),
    (member(2, List) -> write('нет') ; write('да')).
```

Пример работы:

```prolog
?- pass_exam('Иванов'). 
да
true.
```

Проверяет, есть ли среди оценок студента двойка. Сначала получает все оценки студента с помощью `findall`, далее с помощью `member` проверяет, есть ли среди оценок оценка 2, если есть, пишет 'нет', иначе пишет 'да'.

`students_sr()` - для каждого студента ищет средний балл, и сдал ли он экзамены или нет. 

Реализация: 

```prolog
students_sr() :-
    student(_, Name),
    get_student_sr(Name, SrGrades),
    write('Студент: '), write(Name), write(', средний балл: '), write(SrGrades), write(', сдал(а) экзамены: '), pass_exam(Name), write('\n'), fail.
```

Пример работы:

```prolog
?- students_sr().
Студент: Петров, средний балл: 3.8333333333333335, сдал(а) экзамены: да
Студент: Петровский, средний балл: 4.5, сдал(а) экзамены: да
Студент: Иванов, средний балл: 4.5, сдал(а) экзамены: да
Студент: Ивановский, средний балл: 4.166666666666667, сдал(а) экзамены: да
Студент: Запорожцев, средний балл: 3.1666666666666665, сдал(а) экзамены: нет
Студент: Сидоров, средний балл: 3.8333333333333335, сдал(а) экзамены: да
Студент: Сидоркин, средний балл: 4, сдал(а) экзамены: да
Студент: Биткоинов, средний балл: 3.5, сдал(а) экзамены: нет
Студент: Эфиркина, средний балл: 2.8333333333333335, сдал(а) экзамены: нет
Студент: Сиплюсплюсов, средний балл: 4.166666666666667, сдал(а) экзамены: да
Студент: Программиро, средний балл: 4, сдал(а) экзамены: да
Студент: Джаво, средний балл: 3.5, сдал(а) экзамены: нет
Студент: Клавиатурникова, средний балл: 4.166666666666667, сдал(а) экзамены: да
Студент: Мышин, средний балл: 4, сдал(а) экзамены: да
Студент: Фулл, средний балл: 4.5, сдал(а) экзамены: да
Студент: Безумников, средний балл: 3.3333333333333335, сдал(а) экзамены: нет
Студент: Шарпин, средний балл: 4.333333333333333, сдал(а) экзамены: да
Студент: Круглосчиталкин, средний балл: 3.5, сдал(а) экзамены: нет
Студент: Решетников, средний балл: 4, сдал(а) экзамены: да
Студент: Эксель, средний балл: 4, сдал(а) экзамены: да
Студент: Текстописов, средний балл: 3.6666666666666665, сдал(а) экзамены: нет
Студент: Текстописова, средний балл: 3.6666666666666665, сдал(а) экзамены: нет
Студент: Густобуквенникова, средний балл: 3.8333333333333335, сдал(а) экзамены: нет
Студент: Криптовалютников, средний балл: 3, сдал(а) экзамены: нет
Студент: Блокчейнис, средний балл: 4, сдал(а) экзамены: нет
Студент: Азурин, средний балл: 3.3333333333333335, сдал(а) экзамены: нет
Студент: Вебсервисов, средний балл: 3.3333333333333335, сдал(а) экзамены: нет
Студент: Круглотличников, средний балл: 4.166666666666667, сдал(а) экзамены: да
```

Выводит таблицу с ответами задания. При помощи вышеописанных предикатов для каждого студента выводит: Фамилию, средний балл и определяет, сдал ли он экзамены или нет.

### Предикаты второго задания:

Для каждого предмета, найти количество не сдавших студентов

В этом задании я снова решил вывести таблицу. Можно было бы обойтись одним предикатом, но я для наглядности ращделил на два.

`sbj_fail(SbjAbbr, N)`, где SbjAbbr - имя аббревиатура предмета, N - количество двоек за этот предмет.

Реализация: 

```prolog
sbj_fail(SbjAbbr, N) :-
    findall(Name, grade(Name, SbjAbbr, 2), List),
    length(List, N).
```

Пример работы:

```prolog
?- sbj_fail('PSY', N).
N = 5.
```

Ищет количество двоек по определённому предмету. С помощью `findall` получает список, состоящий из фамилий студентов, у которых по предмету SbjAbbr оценка 2. Потом считает длину этого списка.

`fail_exam()` - для каждого предмета ищет количество не сдавших студентов.

Реализация: 

```prolog
fail_exam() :-
    subject(SbjAbbr, Sbj),
    sbj_fail(SbjAbbr, N),
    write('Предмет: '), write(Sbj), write(', количество несдавших: '), write(N), write('\n'), fail.
```

Пример работы:

```prolog
?- fail_exam().
Предмет: Логическое программирование, количество несдавших: 3
Предмет: Математический анализ, количество несдавших: 6
Предмет: Функциональное программирование, количество несдавших: 1
Предмет: Информатика, количество несдавших: 3
Предмет: Английский язык, количество несдавших: 1
Предмет: Психология, количество несдавших: 5
```

Для каждого предмета выводит: название и количество несдавших при помощи вышеописанного предиката `sbj_fail(SbjAbbr, N)`.

### Предикаты третьего задания:

Для каждой группы, найти студента (студентов) с максимальным средним баллом.

`del_first(L,R)`, где L - входящий список, R - обработанный список.

Реализация: 

```prolog
del_first(L,R):- 
    append([_, _, _, _, _, _],R,L).
```

Пример работы:

```prolog
?- del_first([1,2,3,4,5,6,7,8,9,10], R). 
R = [7, 8, 9, 10].
```

Удаляет первые 6 элементов списка. Этот предикат пригодится позже.

`sum_grades_list([A, B, C, D, E, F|_], Grades, SumList, Q)`, где `[A, B, C, D, E, F|_]` и Grades - списки оценок, SumList - сумма оценок, Q - максимальная сумма оценок.

Реализация: 

```prolog
sum_grades_list([A, B, C, D, E, F|_], Grades, SumList, Q) :-
    Sum6 is A + B + C + D + E + F,
    append(SumList, [Sum6], SumList2),
    del_first(Grades, R),
    sum_grades_list(R, R, SumList2, Q).
sum_grades_list(_, [], SumList, Q) :-
    sort(SumList, L),
    reverse(L, P),
    P = [Q|_].
```

Пример работы:

```prolog
?- sum_grades_list([5,5,5,4,5,3,4,4,4,4,3,4,5,4,5,4,3,3,3,5,3,2,4,3,5,2,4,5,4,3], [5,5,5,4,5,3,4,4,4,4,3,4,5,4,5,4,3,3,3,5,3,2,4,3,5,2,4,5,4,3], [], Q).  
Q = 27 ;
false.
```

Он только выглядит таким слодным. Но идея такая: на вход мы ему даём список из 6n (так как предметов шесть) оценок. Он определяет сумму первых шести, добавляет эту сумму в жругой список. У исходного списка удаляет эти первые шести элементов и рекурсивно повторяется. Если на вход поступает пустой список, это значит, что мы уже получили все суммы (для каждого студента). Тогда мы с помощью стандартных предикатов `sort` и `reverse`, соответственно, сортируем и переворачиваем список. Первый его элемент - это максимальна я сумма (не путать со средним), получаем её.

`max_grade_group(Group)`, где Group - это номер группы.

Реализация: 

```prolog
max_grade_group(Group) :-
    findall(Name, student(Group, Name), List),
    findall(Grade, (student(Group, Name), grade(Name, _, Grade)), Grades),
    sum_grades_list(Grades , Grades , [], Q),
    student(_, Name),
    member(Name, List),
    findall(Mark, grade(Name, _, Mark), List2),
    sum(List2, N),
    N = Q,
    write('Самый высокий средний балл в группе '), write(Group), write(' у студента с фамилией '), write(Name), write('\n'), fail.
```

Пример работы:

```prolog
?- max_grade_group(103). 
Самый высокий средний балл в группе 103 у студента с фамилией Сиплюсплюсов
Самый высокий средний балл в группе 103 у студента с фамилией Клавиатурникова
false.
```

Сначала нам нужно получить список студентов из заданной группы. В моём представлении сделать это сложнее, чем в некоторых других. Далее мы получаем список из всех оценок всех учеников в группе и передаём его в вышеописанный предикат `sum_grades_list([A, B, C, D, E, F|_], Grades, SumList, Q)`. Далее для каждого ученика, который состоит в группе (проверка реализована с помощью стандартного предиката `member`) получаем сумму всех его оценок. Если эта сумма равна полученной ранее максимальной сумме, выводим фамилию ученика.

Я не уверен в эффективности работы моей программы. Также меня смущает, что я должен вводить группу сам (хотелось бы, чтобы таблица рисовалась без входных аргументов), а также то, что я удаляю заданное число оценок, ели количество предметов увеличится, код придётся править.


## Выводы

Prolog - это отличный язык, который может быть чрезвычайно полезен при решении ряда задач, связанных с логикой. Например, задачи с множествами или задачи, где есть много каких-то условий. Мощности "пролога" хватает, чтобы их быстро решить. Однако он не является панацеей от всех проблем. Так, нахождение среднего, различные проверки, работа с текстом - любая из этих задач, которые легко решаются на императивном языке программирования, на прологе решается довольно сложно.

Выполнение лабораторной работы поначалу было для меня сложным, однако под конец я понял, как работать с логическим программированием. Конечно, мышление при работе с императивными языками и прологом должно отличаться, однако при достаточной практике всё получается.
