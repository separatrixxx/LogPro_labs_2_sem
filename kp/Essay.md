# Реферат
## по курсу "Логическое программирование"

### студент: Лохматов Н.И.

## Типовые и бестиповые логические языки: обзор и сравнение.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Типовые и бестиповые логические языки: обзор и сравнение.

## Введение

В реферате я попытался изучить две обширные вещи: понятие о типизации и системы типов в логическом программировании. Я сравню различные виды типизации и изучу эту же тему с точки зрения логических языков. 

Свой реферат я решил разделить на две части: в первой речь пойдёт о типизации в языках программирования в целом, я рассмотрю разные виды типизации, их преимущества и недостатки, а во второй части мной будет рассмотрена типизация конкретно я логических языках, некоторые нюансы типизации в логическом программировании, разные логические языки, их сравнение с точки зрения понятия типов в них.

## Понятие типизации в программировании

Типизацией или, как её ещё называют, системой типов называют набор правил в программировании, которые каждой конструкции, составляющей программу (это могут быть переменные, функции, выражения и так далее) присваивают определённое свойство, которое называется типом (данных). К типам в разных языках программирования относятся: числа, числа с плавающей запятой, символы, строки, логические значения, объекты, массивы и так далее. 

В общем все языки программирования делятся на типизированные (типовые) и нетипизированные (бестиповые). К первому множеству относятся большинство языков программирования: C, C++, Python, Java, Go. Ко второму относятся язык ассемблера, эзотерические языки (например, Brainfuck или HQ9). 

### Типизированные языки

В свою очередь среди типизированных языков выделяют несколько пересекающихся между собой категорий: статическая/динамическая, сильная/слабая, явная/неявная.

#### Статическая и динамическая

Типы различных программных конструкций можно установить на этапе компиляции или во время выполнения программы. Если компилятор до выполнения программы уже знает, какая переменная какой тип имеет, то такие языки называется статически типизированными, иначе – динамически типизированными.

К статически типизированным языкам относятся C, Java, C#. К плюсам данной категории можно отнести скорость выполнения программы, так как все проверки, связанные с типами, проходят только один раз на этапе компиляции, а после этого программа будет уверена, что ей не придётся делить строку на объект или выполнять другие странные вещи. Также статическая типизация иногда позволяет выявлять ошибки уже на этапе компиляции.

Среди языков с динамической типизацией выделяют Python, JavaScript, Ruby. Среди их преимуществ: лёгкость и удобство написания универсального кода и обобщённых алгоритмов (различные сортировки, которые одинаково будут работать, например, для массива целый или вещественных чисел).

#### Сильная и слабая

Языки с сильной типизацией не позволяют смешивать переменные различных типов и выполнять неявные преобразование, а языки со слабой типизацией выполняют различные неявные преобразования автоматически, несмотря на возможную потерю точности или неоднозначность самого преобразования.

Такие языки, как Java, Python, Lisp имеют сильную типизацию. Они отличаются своей надёжностью, так как программист получит ошибку при компиляции. Также в силу того, что программе нет необходимости совершать неявные преобразования, такие языки имеют более высокую скорость. К плюсам можно отнести и общее понимание программистом хода работы программы.

C, JavaScript, PHP – это языки со слабой типизацией. Несмотря на то, что сильная типизация кажется (и вполне справедливо) более выгодной, у слабой типизации также можно выделить несколько плюсов. Конечно, это краткость кода, а также то, что программисту не нужно думать о типизации и можно сосредоточиться исключительно на выполнении задачи.

#### Явная и неявная

Если язык программирования требует от программиста явного задания типа переменных и функций, то это язык имеет явную типизацию. Если эта задача перекладывается на компилятор, то язык имеет неявную типизацию.

Явную типизацию имеют C, C++, C#. В таких языках не возникает проблемы в определении, что функции делают, так как у каждой функции есть чёткая сигнатура `(function sum(a: number, b: number): number)`. 

Среди языков с неявной типизацией выделяют PHP, Python, JavaScript. В отличие от языков с явной типизацией, сокращается запись, например функций. В предыдущем примере я записал определение функции на языки TypeScript, на JavaScript такое же определение выглядело бы так: `function sum(a, b)`. Запись стала заметно короче. Также такая функция будет более универсальной, так как с её помощью мы можем сложить не только числа, но и, например, строки.

### Нетипизированные языки

В таких языках все конструкции программы считаются последовательностями бит различной длины. У таких языков тоже есть ряд преимуществ:
- Код становится более эффективным
- Программы можно писать на более низком уровне
-	Прозрачность инструкций

Однако подобный код будет довольно сложным, так же из-за отсутствия проверки типов могут возникнуть разного рода ошибки. 

### Вывод по первой части

Мы рассмотрели базовые понятия типизации, разные её категории, их сравнения, плюсы и минусы. Пока что можно сделать вывод о том, что хорошие языки программирования должны иметь статическую типизацию для увеличения эффективности работы программ и более лёгкого обнаружения ошибок в коде. Также стало ясно, что типизация в принципе довольно сильно упрощает жизнь программистам. Теперь мы попробуем переложить эти знания на логические языки и рассмотреть их более детально.

## Типизация в логическом программировании

Изначально такое понятие, как типизация, не использовалось логическими языками, ведь исчисление предикатов не использует типы. Если говорить про логику, то в качестве переменных тут могут выступать сколь угодно сложные термы переменной длины, поэтому понятие типов в том виде, в котором он представлен в императивных языках, неуместно. Также попытка ввести типы данных в логическом программировании привела бы к тому, что структура данных сильно бы усложнилась, вследствие чего модели для систем искусственного интеллекта, для реализации которых данные языки изначально и создавались, значительно бы усложнились.

Однако со временем было доказано, что типы данных полезны не только в императивном программировании, но и в логическом, и функциональном (в котором типов изначально тоже не было). Благодаря типам программистам легче обнаружить ошибки в программе, в том числе и логические. Поэтому в логическом программировании ввели понятие типа, прежде всего для того, чтобы на ранней стадии написания кода выявлять логические ошибки и отличать значимые термы от бессмысленных. Тип в данном семействе языков представляет собой набор термов, связанных с позицией аргумента. Такое представление отражает понимание программистом, какой вид терма ожидается в той или иной позиции аргумента. У программистов в Prolog-подобных логических языках отпадает потребность сообщать программе информацию о типах (например, объявление типов, как в императивных языках: `int a = 0`, `let a: number = 0` и так далее), поскольку всю информацию она сама распознаёт через систему объектов. У объектов тоже существует классификация, и система распознаёт его тип по его синтаксической форме. Делается это довольно удобно, ведь согласно синтаксису Prolog’а разные типы объектов данных должны иметь разные формы записи. Например, мы можем легко отличить переменную от атома, ведь переменные обязательно должны начинаться с прописной буквы, а атомы – со строчной. Если программист будет следовать этим правилам, система, проанализировав код программы, распознает в нём разные объекты данных, и программисту не придётся самому объяснять ей, какой объект к какому типы принадлежит, как это нужно делать в императивных языках.

### Статическая система типов

Статическая типизация, конечно, почти всегда лучше динамической, в этом мы убедились выше. Так что если речь идёт про создание хорошего типизированного языка, то следует выбрать именно статическую типизацию. Для изобретения статической типизации в логических (и функциональных) языках строится теория, которая называется по имени создателя – система типов Майкрофта О’Кифа. Суть всей теории заключается в том, чтобы ещё до начала выполнения программы проверять корректность типов. Система типов Майкрофта О‘Кифа базируется на многосортной логике предикатов и состоит в том, что кроме формальной системы ввода будет существовать дополнительная система ввода для каждого из термов, которые, собственно, должны участвовать в выводе. Эта дополнительная система строится параллельно основной таким образом, что шаг логического вывода на будет нарушать правильность типизации. Программисту нужно всего лишь проверять правильность типизации вводимых выражений, используя некоторый процесс вывода типов. Такой подход призван обеспечить корректность типов у вводимых объектов, что означает, что шаг логического вывода сохраняет правильность типизации, поэтому не стоит тратить время на проверку типов во время выполнения. 

Ещё одна интересная особенность типизации логических языков заключается в том, что, например, для использования предикатов, которые будут работать со списками, мы часто хотим, чтобы в этот список могли входить объекты разных типов. Поэтому таких предикаты списка должны быть полиаморфными. То есть к системе типизации в логических языках можно применять такое понятие, как полиморфизм или, например, параметрическая типизация (параметрический полиморфизм), благодаря которой мы можем обрабатывать объекты, имеющие разные типы данных. Также к таким системам применимо понятие вывода типов, когда система сама понимает, какого типа данных объекты, входяшие в некоторое выражение.

### Окружение

В общем случае в логических языках существует множество типов, как их ещё называют сортов, T. Это множество помимо примитивных встроенных типов содержит в себе конструкторы типов для построения новых типов, также это множество чаще всего является бесконечным. С помощью конструкторов типов можно построить, например, списки, содержание данные разных примитивных типов, используя при этом эти типы. Для термов мы можем ввести понятие объявления типа. То есть мы берём некую небольшую конструкцию, которая ставит в соответствие каждому терму некоторый тип. Множество таких объявлений называется окружением. Выражение будет считаться правильно типизированным, если входящие в него переменные имеют прописанные типы. Грубо говоря, окружением называют предположение о типах термов, в простом случае оно является набором соответствие «терм – его тип». Также из любого окружения можно вывести заключение. Приведу пример. Мы имеем переменную `A`, имеющую тип `integer`, и список `L`, соответственно, типа `list`, состоящий из значений типа `integer`. С помощью системы вывода из данной нам информации мы можем вывести, что `[A|L]` имеет тип `list(integer)`. Это называется понятием выводимости, то есть существует множество правил вывода, которые позволяют нам говорить о том, что если из окружения можно вывести какие-либо посылки, то можно также вывести и какие-то другие посылки. Конструирование типов происходит на основе многосортной логики предикатов.

### Корректность системы типов

Для получения хорошего языка с сильной типизацией нужно следовать некоторым правилам. Про наличие статической типизации мы уже поговорили выше. Но также нам бы хотелось, чтобы из выражения, про которое мы с уверенностью можем сказать, что это правильно типизировано, делается шаг вывода, то получается новое выражение, которое также обязано быть правильно типизировано. То есть, если говорить в общем, после шага вывода из правильно типизированного выражения, должно получиться некое следствие. Это свойство называется корректностью системы типов относительно формальной системы вывода. Если из некоторого окружения нам удалось вывести утверждение `T`, и мы знаем, что типизация `T` полностью корректна и удовлетворяет нашим ожиданиям, то если мы можем доказать наше утверждение касательно правильности типизации `T` в данном окружении, а их утверждения `T`, используя формальную систему вывода, мы получаем выражение `T’`, то согласно свойству корректности системы типов, `C’` будет являться правильно типизированным выражением. Это свойство даёт нам много плюсов. Очевидно, нам не нужно будет множество раз проверять корректность типов в программе, если мы уже проверили эту корректность в начале, то есть статический контроль полностью покрывает правильность типизации в программе.

### Классы конкретизации и режимы доказательства

Когда мы пишем предикаты на логических языках, мы бы хотели, чтобы эти предикаты мы могли использовать в разных контекстах. Если нам не будет важно, какие аргументы передаются в предикат и какие из них конкретизированы, это придаст нашей программе ещё большей гибкости и некоторой модульности, к тому же нам не придётся задумываться в типизации. Для реализации этой идеи используется режим доказательства, он определяет, в каком контексте вызывается предикат, в плане того, какие аргументы являются конкретизированными, а какие – нет. У режимов доказательств существуют свои собственные деревья вывода, определяющие, как будет строиться резолюция SLD для контекста вызова, причём каждое дерево будет отличаться от других деревьев. Также у каждого режима доказательства существует специфика выполнения предикатов, которую учитывает система программирования. Режимы доказательств имеют одну интересную особенность, благодаря которой нам не нужно рассматривать все режимы, можно ограничиться только основными, потому что некоторые режимы доказательств являются частными случаями других.

Переменные можно классифицировать и выделить две группы: входные – переменные, которые были конкретизированы к времени вызова предиката, и выходные – переменные, которые стали конкретизированными во время вызова предиката, а до этого являлись свободными. Режим доказательства определяется тем, какие переменные являются входными, а какие выходными. Однако в логическом программировании не всегда по переменной можно сказать, была ли она конкретизирована, можно представить предикат, режим доказательства которого принимает на вход неопределённую переменную в том смысле, что он не знает, конкретизирована она или нет, подставляет в неё какие-либо значения и в таком виде передаёт на выход. Например, программа принимает шаблон списка, а выводит всевозможные заполнения этого шаблона. Именно поэтому нам недостаточно только того знания, входная переменная или выходная, если мы не хотим получать странные результаты. Именно поэтому вводят понятие класс конкретизации, которые должен показать, как именно конкретизирована переменная. Например, переменные free и ground – свободная и полностью конкретизированная переменные соответственно. Также возможны полуконкретизированные переменные.

### Детерминизм

Под детерминизмом в общем понимают взаимосвязь разных явлений и процессов. В логических языках в каждом режиме доказательства предикат может иметь различный детерминизм. Итогом работы какого-либо предиката являются три варианта: когда мы не получаем ни одного решения, когда мы получаем только одно решение, и когда мы получаем более одного решения. Стоит также обратить внимание на то, что возможна какая-нибудь ошибка, и предикат просто не выполнится. Может показаться, что это означает, что решений нет, однако это не совсем так. Однако если решений нет, и мы точно уверены в том, что отказ невозможен, то такого просто не может быть, однако если отказ всё же возможен, то это значит, что при его выполнении всегда будет отказ. Если мы получили одно решение, и невозможен, то мы получили детерминированный предикат – классическую функцию, всегда дающую результат. Если после выполнения предиката мы получили одно решение, при этом возможен отказ, то это полудетерминированный предикат. Это значит, она неопределен на некоторых аргументах, а на всех остальных ведёт себя вполне нормально. А если решений больше, чем одно, отказ при этом невозможен, то такой предикат называется мультидетерминированным, а если отказ всё-таки возможен, то такой предикат называется недетерминированным. 
Существует также детерминированный выбор, означающий, что если наш предикат является мультидетерминированым, который выдаёт больше одного решения, но нас при этом интересует только одно, то в этом случае мы можем описать его, как выбор. Об этом следует думать, что система программирования сама будет заинтересована в поиске единственного решения, а когда она его найдёт, она завершится, ведь ей незачем искать другие решения, даже если они есть.

### Типизация в некоторых логических языках

В этом подразделе мы рассмотрим три логических языка с точки зрения их типизации. Начнём мы с языка Prolog, так как он по типизации является самым примитивным в выбранной тройке. Далее рассмотрим VisualProlog и Mercury. Попытаемся разобрать основные структуры языков, особые случаи, сравним эти языки между собой.

#### Prolog

Сам по себе Prolog не является типовым, то есть вместо нескольких типов данных в нём присутствует один универсальный тип данных, который принято называть термом. Грубо говоря, все объекты данных в Prolog’е – термы, большего и не надо, ведь все возможные типы данных в рамках этого языка вполне хорошо покрываются термами. Prolog использует динамический контроль типов, осуществляемый во время работы программы. У термов тоже есть чёткая классификация. На самом верхнем уровне термы делятся на простые и структурные. Простое в свою очередь делятся на константы и переменные, а константы же могут представлять из себя числа или атомы. Итак, мы имеем: атом, число (может быть целым или вещественным), переменная (строка из букв, цифр, знаков нижнего подчёркивания, которая начинается либо с заглавной буквы, либо со знака подчёркивания), составной терм, представляющий из себя атом и ряд аргументов, которые снова являются термами. Составной терм обычно записывается в виде функтора со следующим за ним и разделённым запятыми список аргументов.  Также в языке пролог встречаются особые случаи типов данных: 

-	Список. Представляет собой упорядоченный набор термов, обозначается квадратными скобками. Если список пустой, то внутри скобок ничего не пишется, в других же случаях в скобках содержатся члены данного списка, разделённые запятыми. Списки играют важную роль, поскольку они добавляют возможность иметь структуру, которая не имеет определённого заранее количества элементов, то есть их состав и, соответственно длину, можно изменять. Так как в Prolog’е нет типизации, нам не нужно объявлять типы данных различных элементов, следовательно, в списках могут храниться разнообразные элементы, в том числе другие списки.
-	Строки. Являются последовательностью символов, заключённых в кавычки. Строки являются аналогом списков кодов символов в одной кодировке, чаще – в кодировке локального символа или в Unicode, если система его поддерживает.

#### VisualProlog

VisualProlog является объектно-ориентированным расширением PDC Prolog, относящимся к семейству языков Prolog. В этом языке присутствует строгая типизация данных, что, во-первых, отличает его от «классического» Prolog’а, а, во-вторых, это заметно повышает скорость выполнения программ. Типы данных в VisualProlog называются доменами, которые описываются в начале программы, там же описываются предикаты. Правила в этом языке нельзя добавлять и удалять во время работы программы, так как правила не являются данными. Из-за этого же отсутствует возможность сопоставлять имя предиката с переменной. Внутреннюю базу данных (их может быть несколько) изменять можно, например, добавлять или удалять из неё факты. Любая программа на VisualProlog содержит несколько разделов:

-	Домены, где описываются типы данных
-	Константы – описывается имя и соответствующее ему значение
-	Факты (истинные предикаты)
-	Предикаты
-	Предложения – набор фактов и правил, необходимые системе для разрешения цели программы
-	Цель – цель программы, сформулированная на языке Prolog

Типы доменов «из коробки» обычно представлены символами, целыми и действительными числами, строками, символьными именами, ссылочным типом и файлами. Существует также возможность добавления новых доменов, для этого их нужно описать в разделе domains, там же можно добавлять структурные (составные) домены, аналогичные структурным термам из классического Prolog’а.

#### Mercury

Mercury является функционально-логическим языком нового поколения со строгой типизацией. Mercury основан на языке Prolog, унаследовал от него часть синтаксиса и призван решить две его проблемы: проблему производительности (по понятным причинам логические языки сильно уступают императивным по производительности) и проблему отладки (в языках логического типа происходит мало проверок во время компиляции, из-за чего программисту сложно найти ошибку в коде программы самому). Mercury имеет ряд преимуществ в сравнении с классическим Prolog’ом:

-	Систему типов и режим предикатов
-	Элементы функционального программирования
-	Функции высшего порядка
-	Автоматическая оптимизация
-	Большая библиотека предикатов
-	Модульное программирование

На языке Mercury программы имеют чёткую структуру:

-	`:−module` – заголовок модуля
-	`:−interface` – интерфейсная часть, то есть, то что мы делаем доступным другим модулям (хотя бы один модуль должен экспортировать `main`)
-	`:−import_module` – импортируем данные из модулей, которые нам нужны
-	`:-type` – здесь задаются пользовательские типы данных
-	`:−pred` – определение предиката, в нем указываются типы аргументов, режимы предиката и варианты детерминизма для каждого из режимов.
-	`:-func` – определение функции
-	`:-mode` – установление режима для предиката или функции
-	Предикат `main`, с которого начинается работа программы
-	`:−implementation` – реализация предикатов
-	
Встроенные или библиотечные типы данных на языке Mercury:

-	Примитивы, к которым относятся `int`, `float`, `string` и `char`
-	Предикаты
-	Функции
-	Кортежи
-	Универсальный тип
-	Все типы из языка Prolog

## Вывод

После изучения типизации различных языков, её классификацию, плюсы и минусы, можно сделать вывод о том, что, как минимум, типизированные языки намного быстрее нетипизированных. Также типизация даёт уверенность программисту в безопасности программы и помогает ему выявлять ошибки. По большей части это касается статически типизированных языков, в том числе и логических, где проверка типов осуществляется так же, как и во всех других языках. Однако у бестиповых языков, таких Prolog, тоже есть немного плюсов. Например, код на них легко писать, не нужно думать о типах, используемых в программе и над режимами предикатов. Если вы хотите изучить логическое программирование, то определённо стоит начать именно с бестиповых языков, однако отлавливать ошибки и отлаживать программу становится очень сложно. Приходится самому искать баги, а если код программы объёмный, сделать это затруднительно. Однако, как мы убедились, существуют Prolog-подобные языки, в которых многие проблемы бестипового классического Prolog’а решены. Поэтому для продолжения развития навыков программиста на логических языках следует переключиться на них, а сделать это максимально просто.

В процессе написания данного эссе я узнал много нового о типизации и о целом семействе логических языков. Возможно, данная парадигма уже не является актуальной, однако эти знания несомненно пригодятся мне в программировании на других языках.

## Используемая литература

-	Парадигма логического программирования, Сошников Д.В., 2006
-	Введение в логическое программирование, Хоггер Кю, 1988
-	Типы в логическом программировании, Пфеннинг, Ф., 1992
-	Режимы и типы в логическом программировании, Смаус Я., 1999
